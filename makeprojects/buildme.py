#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Module that contains the code for the command line "buildme".

Scan the current directory and all projects files will be built.

If build_rules.py is found, it will be parsed for a build_rules.BUILD_LIST and
if one isn't found a default buildme.BUILD_LIST is used. If the functions
listed in the buildme.BUILD_LIST exist, they will be called in priority order.

Build commands are performed from lowest priority value to highest value.

See Also:
    main, makeprojects.cleanme, makeprojects.rebuildme

"""

## \package makeprojects.buildme

from __future__ import absolute_import, print_function, unicode_literals

import os
import sys
import argparse
from struct import unpack as struct_unpack
from operator import attrgetter
import xml.etree.ElementTree as ET
from burger import where_is_doxygen, create_folder_if_needed, \
    get_windows_host_type, get_mac_host_type, delete_file, save_text_file, \
    load_text_file, run_command, read_zero_terminated_string, \
    where_is_watcom, host_machine, import_py_script, where_is_visual_studio, \
    is_codewarrior_mac_allowed, where_is_codeblocks, run_py_script, \
    where_is_xcode
from .__pkginfo__ import VERSION
from .config import BUILD_RULES_PY
from .__init__ import _XCODEPROJ_MATCH

## Default build function list, priority / entrypoint
BUILD_LIST = (
    (1, 'prebuild'),
    (40, 'build'),
    (99, 'postbuild')
)

## Error code messages from Codewarrior
CODEWARRIOR_ERRORS = (
    None,
    'error opening file',
    'project not open',
    'IDE is already building',
    'invalid target name (for /t flag)',
    'error changing current target',
    'error removing objects',
    'build was cancelled',
    'build failed',
    'process aborted',
    'error importing project',
    'error executing debug script',
    'attempted use of /d together with /b and/or /r'
)

## List of supported Codewarrior Linkers
_CW_SUPPORTED_LINKERS = (
    'MW ARM Linker Panel',      # ARM for Nintendo DSI
    'x86 Linker',               # Windows
    'PPC Linker',               # macOS PowerPC
    '68K Linker',               # macOS 68k
    'PPC EABI Linker'           # PowerPC for Nintendo Wii
)

## Lookup for Visual Studio year in SLN file.
_VS_VERSION_YEARS = {
    '2012': 2012,
    '2013': 2013,
    '14': 2015,
    '15': 2017,
    '16': 2019
}

## Lookup for Visual Studio year in SLN file pre-2012.
_VS_OLD_VERSION_YEARS = {
    '8.00': 2003,
    '9.00': 2005,
    '10.00': 2008,
    '11.00': 2010,
    '12.00': 2012
}

## Lookup for Visual Studio SDK detector.
_VS_SDK_ENV_VARIABLE = {
    'PSP': 'SCE_ROOT_DIR',          # PSP
    'PS3': 'SCE_PS3_ROOT',          # PS3
    'ORBIS': 'SCE_ORBIS_SDK_DIR',   # PS4
    'PSVita': 'SCE_PSP2_SDK_DIR',   # PS Vita
    'Xbox': 'XDK',                  # Xbox classic
    'Xbox 360': 'XEDK',             # Xbox 360
    'Xbox ONE': 'DurangoXDK',       # Xbox ONE
    'Wii': 'REVOLUTION_SDK_ROOT',   # Nintendo Wii
    'Switch': 'NINTENDO_SDK_ROOT',  # Nintendo Switch
    'Android': 'ANDROID_NDK_ROOT',  # Generic Android tools
    'ARM-Android-NVIDIA': 'NVPACK_ROOT',        # nVidia android tools
    'AArch64-Android-NVIDIA': 'NVPACK_ROOT',    # nVidia android tools
    'x86-Android-NVIDIA': 'NVPACK_ROOT',        # nVidia android tools
    'x64-Android-NVIDIA': 'NVPACK_ROOT',        # nVidia android tools
    'Tegra-Android': 'NVPACK_ROOT'              # nVidia android tools
}

########################################


class BuildError:
    """
    Error message generated by builders.

    When a builder completes, a BuildError class is created and appended
    to the ``results`` list for logging.
    """

    def __init__(self, error, filename, configuration=None, msg=None):
        """
        Initializers for an BuildError.

        Args:
            error: Integer error code, zero if not error
            filename: File that generated the error
            configuration: If applicable, configuration that was compiled
            msg: Error message test, if available

        """

        ## Integer error code.
        self.error = error

        ## File name that generated the error.
        self.filename = filename

        ## Build configuration.
        self.configuration = configuration

        ## Error message.
        self.msg = msg

    def __repr__(self):
        """
        Convert the error into a string.

        Returns:
            A full error string.
        """

        if self.error:
            result = 'Error #{} in file {}'.format(self.error, self.filename)
        else:
            result = 'No error in file {}'.format(self.filename)

        if self.configuration:
            result += ' Configuration "{}"'.format(self.configuration)
        if self.msg:
            result += ' "{}"'.format(self.msg)

        return result

    __str__ = __repr__

    def get_error_code(self):
        """
        Return the integer error code.
        """
        return self.error

########################################


class BuildObject:
    """
    Object describing something to build.

    When the directory is parsed, a list of BuildObjects is
    generated and then sorted by priority and then built.
    """

    def __init__(self, file_name, build_type, priority, function_ref=None):
        """
        Initializers for an BuildObject.

        Args:
            file_name: Name of the file to build.
            build_type: Tool to use to build this file.
            priority: Integer priority, lower will be built first.
            function_ref: If python, function to invoke.

        """

        ## Name of file to build.
        self.file_name = file_name

        ## Tool to invoke.
        self.build_type = build_type

        ## Numeric priorty in ascending order.
        self.priority = priority

        ## Function reference for python builds
        self.function_ref = function_ref

    def __repr__(self):
        """
        Convert the object into a string.

        Returns:
            A full string.
        """

        result = (
            'BuildObject for file "{}" using '
            'tool "{}" with priority {}').format(
                self.file_name,
                self.build_type,
                self.priority)
        if self.function_ref:
            result += ' calling function "{}"'.format(
                self.function_ref.__name__)
        return result

    __str__ = __repr__

    def has_python_function(self):
        """
        Return True if there's a callable python function.

        Returns:
            True if there is a callable python function.
        """
        return callable(self.function_ref)

########################################


def build_rez_script(full_pathname, verbose=False):
    """
    Build a rezfile using ``makerez``.

    Execute the program ``makerez`` to build the script.

    Args:
        full_pathname: Pathname to the *.rezscript to build
        verbose: True if verbose output
    Returns:
        BuildError object
    """

    # Create the build command
    cmd = ['makerez', full_pathname]
    if verbose:
        # Have makerez be verbose
        cmd.insert(1, '-v')
        print(' '.join(cmd))

    # Perform the command
    try:
        error_code = run_command(
            cmd, working_dir=os.path.dirname(full_pathname),
            quiet=not verbose)[0]
        msg = None
    except OSError as error:
        error_code = getattr(error, 'winerror', error.errno)
        msg = str(error)
        print(msg, file=sys.stderr)

    # Return the results
    return BuildError(error_code, full_pathname, msg=msg)

########################################


def build_slicer_script(full_pathname, verbose=False):
    """
    Build slicer data using ``slicer``.

    Execute the program ``slicer`` to build the script.

    Args:
        full_pathname: Pathname to the *.slicer to build
        verbose: True if verbose output
    Returns:
        BuildError object
    """

    # Create the build command
    cmd = ['slicer', full_pathname]
    if verbose:
        print(' '.join(cmd))

    # Perform the command
    try:
        error_code = run_command(
            cmd, working_dir=os.path.dirname(full_pathname),
            quiet=not verbose)[0]
        msg = None
    except OSError as error:
        error_code = getattr(error, 'winerror', error.errno)
        msg = str(error)
        print(msg, file=sys.stderr)

    # Return the results
    return BuildError(error_code, full_pathname, msg=msg)


########################################


def build_doxygen(full_pathname, verbose=False):
    """
    Build documentation using Doxygen.

    Execute the program ``doxygen`` to create documentation for the
    project building built.

    If the input file is found to have CR/LF line endings on a macOS
    or Linux platform, the file will have the CRs stripped before
    being passed to Doxygen to get around a bug in Doxygen where
    the macOS/Linux versions require LF only line endings.

    All Doxygen errors will be captured and stored in a file called
    temp/doxygenerrors.txt. If there were no errors, this file
    will be deleted if it exists.

    Args:
        full_pathname: Pathname to the doxygen config file
        verbose: True for verbose output
    Returns:
        BuildError object
    """

    # Is Doxygen installed?

    doxygenpath = where_is_doxygen(verbose=verbose)
    if doxygenpath is None:
        error_code = 10
        msg = '{} requires Doxygen to be installed to build!'.format(
            full_pathname)
    else:

        # Determine the working directory
        full_pathname = os.path.abspath(full_pathname)
        doxyfile_dir = os.path.dirname(full_pathname)

        # Make the output folder for errors (If needed)
        temp_dir = os.path.join(doxyfile_dir, 'temp')
        create_folder_if_needed(temp_dir)

        # The macOS/Linux version will die if the text file isn't Linux
        # format, copy the config file with the proper line feeds
        if get_windows_host_type() is False:
            doxyfile_data = load_text_file(full_pathname)
            temp_doxyfile = full_pathname + '.tmp'
            save_text_file(temp_doxyfile, doxyfile_data, line_feed='\n')
        else:
            temp_doxyfile = full_pathname

        # Create the build command
        cmd = [doxygenpath, temp_doxyfile]
        if verbose:
            print(' '.join(cmd))

        # Capture the error output
        stderr = run_command(cmd, working_dir=doxyfile_dir,
                             quiet=not verbose, capture_stderr=True)[2]

        # If there was a temp doxyfile, get rid of it.
        if temp_doxyfile != full_pathname:
            delete_file(temp_doxyfile)

        # Location of the log file
        log_filename = os.path.join(temp_dir, 'doxygenerrors.txt')

        # If the error log has something, save it.
        if stderr:
            save_text_file(log_filename, stderr.splitlines())
            error_code = 10
            msg = 'Errors stored in {}'.format(log_filename)
        else:
            # Make sure it's gone since there's no errors
            delete_file(log_filename)
            error_code = 0
            msg = None

    # Return the results
    return BuildError(error_code, full_pathname, msg=msg)

########################################


def build_watcom_makefile(full_pathname, verbose=False, fatal=False):
    """
    Build Watcom MakeFile.

    On Linux and Windows hosts, this function will invoke the ``wmake``
    tool to build the watcom make file.

    The PATH will be temporarily adjusted to include the watcom tools so wmake
    can find its shared libraries.

    The default target built is ``all``.

    Args:
        full_pathname: Pathname to the doxygen config file
        verbose: True for verbose output
        fatal: If True, abort on the first failed build
    Returns:
        List of BuildError objects
    """

    # Is Watcom installed?
    watcom_path = where_is_watcom(verbose=verbose)
    if watcom_path is None:
        return BuildError(
            0, full_pathname,
            msg='{} requires Watcom to be installed to build!'.format(
                full_pathname))

    # Watcom requires the path set up so it can access link files
    saved_path = os.environ['PATH']
    if get_windows_host_type():
        new_path = os.pathsep.join(
            (os.path.join(
                watcom_path, 'binnt'), os.path.join(
                    watcom_path, 'binw')))
    else:
        new_path = os.path.join(watcom_path, 'binl')

    exe_name = where_is_watcom('wmake', verbose=verbose)
    os.environ['PATH'] = new_path + os.pathsep + saved_path

    commands = []
    # New format has an 'all' target
    commands.append(([exe_name, '-e', '-h', '-f', full_pathname, 'all'], 'all'))

    # Iterate over the commands
    results = []
    for cmd in commands:
        if verbose:
            print(' '.join(cmd[0]))
        # Perform the command
        try:
            error_code = run_command(
                cmd[0], working_dir=os.path.dirname(full_pathname),
                quiet=not verbose)[0]
            msg = None
        except OSError as error:
            error_code = getattr(error, 'winerror', error.errno)
            msg = str(error)
            print(msg, file=sys.stderr)
        results.append(
            BuildError(
                error_code,
                full_pathname,
                configuration=cmd[1],
                msg=msg))
        if error_code and fatal:
            break

    # Restore the path variable
    os.environ['PATH'] = saved_path

    # Return the error code
    return results

########################################


def build_makefile(full_pathname, verbose=False, fatal=False):
    """
    Build MakeFile using ``make``.

    For Linux hosts, invoke ``make`` for building a makefile.

    The default target built is ``all``.

    Args:
        full_pathname: Pathname to the makefile
        verbose: True for verbose output
        fatal: If True, abort on the first failed build
    Returns:
        List of BuildError objects
    """

    # Running under Linux?
    if host_machine() != 'linux':
        return BuildError(
            0, full_pathname, msg='{} can only build on Linux!'.format(
                full_pathname))

    commands = []
    # New format has an 'all' target
    commands.append((['make', '-s', '-f', full_pathname, 'all'], 'all'))

    # Iterate over the commands
    results = []
    for cmd in commands:
        if verbose:
            print(' '.join(cmd[0]))
        # Perform the command
        try:
            error_code = run_command(
                cmd[0],
                working_dir=os.path.dirname(full_pathname),
                quiet=not verbose)[0]
            msg = None
        except OSError as error:
            error_code = getattr(error, 'winerror', error.errno)
            msg = str(error)
            print(msg, file=sys.stderr)
        results.append(
            BuildError(
                error_code,
                full_pathname,
                configuration=cmd[1],
                msg=msg))
        if error_code and fatal:
            break

    # Return the error code
    return results

########################################


def parse_sln_file(full_pathname):
    """
    Find build targets in .sln file.

    Given a .sln file for Visual Studio 2003, 2005, 2008, 2010,
    2012, 2013, 2015, 2017 or 2019, locate and extract all of the build
    targets available and return the list.

    It will also determine which version of Visual
    Studio this solution file requires.

    Args:
        full_pathname: Pathname to the .sln file
    Returns:
        tuple(list of configuration strings, integer Visual Studio version year)
    See Also:
        build_visual_studio
    """

    # Load in the .sln file, it's a text file
    file_lines = load_text_file(full_pathname)

    # Version not known yet
    vs_version = 0

    # Start with an empty list
    target_list = []

    if file_lines:
        # Not looking for 'Visual Studio'
        looking_for_visual_studio = False

        # Not looking for EndGlobalSection
        looking_for_end_global_section = False

        # Parse
        for line in file_lines:

            # Scanning for 'EndGlobalSection'?

            if looking_for_end_global_section:

                # Once the end of the section is reached, end
                if 'EndGlobalSection' in line:
                    looking_for_end_global_section = False
                else:

                    # The line contains 'Debug|Win32 = Debug|Win32'
                    # Split it in half at the equals sign and then
                    # remove the whitespace and add to the list
                    target = line.split('=')[-1].strip()
                    if target not in target_list:
                        target_list.append(target)
                continue

            # Scanning for the secondary version number in Visual Studio 2012 or
            # higher

            if looking_for_visual_studio and '# Visual Studio' in line:
                # The line contains '# Visual Studio 15' or '# Visual Studio
                # Version 16'

                # Use the version number to determine which visual studio to
                # launch
                vs_version = _VS_VERSION_YEARS.get(line.rsplit()[-1], 0)
                looking_for_visual_studio = False
                continue

            # Get the version number
            if 'Microsoft Visual Studio Solution File' in line:
                # The line contains
                # 'Microsoft Visual Studio Solution File, Format Version 12.00'
                # The number is in the last part of the line
                # Use the version string to determine which visual studio to
                # launch
                vs_version = _VS_OLD_VERSION_YEARS.get(line.split()[-1], 0)
                if vs_version == 2012:
                    # 2012 or higher requires a second check
                    looking_for_visual_studio = True
                continue

            # Look for this section, it contains the configurations
            if '(SolutionConfigurationPlatforms)' in line or \
                    '(ProjectConfiguration)' in line:
                looking_for_end_global_section = True

    # Exit with the results
    if not vs_version:
        print(
            ('The visual studio solution file {} '
             'is corrupt or an unknown version!').format(full_pathname),
            file=sys.stderr)
    return (target_list, vs_version)

########################################


def build_visual_studio(full_pathname, verbose=False, fatal=False):
    """
    Build a visual studio .sln file.

    Supports Visual Studio 2005 - 2019. Supports platforms Win32, x64,
    Android, nVidia Tegra, PS3, ORBIS, PSP, PSVita, Xbox, Xbox 360, Xbox ONE,
    Switch, Wii

    Args:
        full_pathname: Pathname to the Visual Studio .sln file
        verbose: True for verbose output
        fatal: If True, abort on the first failed build
    Returns:
        List of BuildError objects
    See Also:
        parse_sln_file
    """

    # Get the list of build targets
    targetlist, vs_version = parse_sln_file(full_pathname)

    # Was the file corrupted?
    if not vs_version:
        return BuildError(10, full_pathname, msg=full_pathname + ' is corrupt!')

    # Locate the proper version of Visual Studio for this .sln file
    vstudiopath = where_is_visual_studio(vs_version)

    # Is Visual studio installed?
    if vstudiopath is None:
        msg = ('{} requires Visual Studio version {}'
               ' to be installed to build!').format(full_pathname, vs_version)
        print(msg, file=sys.stderr)
        return BuildError(0, full_pathname, msg=msg)

    # Build each and every target
    results = []
    for target in targetlist:

        # Certain targets require an installed SDK
        # verify that the SDK is installed before trying to build

        targettypes = target.rsplit('|')
        test_env = _VS_SDK_ENV_VARIABLE.get(targettypes[1], None)
        if test_env:
            if os.getenv(test_env, default=None) is None:
                msg = (
                    'Target {} was detected but the environment variable {} '
                    'was not found.').format(targettypes[1], test_env)
                print(msg, file=sys.stderr)
                results.append(
                    BuildError(
                        0,
                        full_pathname,
                        configuration=target,
                        msg=msg))
                continue

        # Create the build command
        # Note: Use the single line form, because Windows will not
        # process the target properly due to the presence of the | character
        # which causes piping.

        # Visual Studio 2003 doesn't support setting platforms, just use the
        # configuration name
        if vs_version == 2003:
            target = targettypes[0]

        cmd = [vstudiopath, full_pathname, '/Build', target]
        if verbose:
            print(' '.join(cmd))
        sys.stdout.flush()
        try:
            error_code = run_command(
                cmd, working_dir=os.path.dirname(full_pathname),
                quiet=not verbose)[0]
            msg = None
        except OSError as error:
            error_code = getattr(error, 'winerror', error.errno)
            msg = str(error)
            print(msg, file=sys.stderr)
        results.append(
            BuildError(
                error_code,
                full_pathname,
                configuration=target,
                msg=msg))
        if error_code and fatal:
            break

    return results

########################################


def parse_mcp_file(full_pathname):
    """
    Extract configurations from a Metrowerks CodeWarrior project file.

    Given an .mcp file for Metrowerks Codewarrior, determine
    which version of Codewarrrior was used to build it.

    It will parse Freescale Codewarrior for Nintendo (59), Metrowerks
    Codewarrior 9.0 for Windows (50) and Metrowerks Codewarrior 10.0
    for macOS (58)

    Args:
        full_pathname: Pathname to the .mcp file
    Returns:
        tuple(list of configuration strings, integer CodeWarrior Version)
    See Also:
        build_codewarrior
    """

    # Handle ../../
    full_pathname = os.path.abspath(full_pathname)

    try:
        # Load in the .mcp file, it's a binary file
        with open(full_pathname, 'rb') as filep:

            # Get the signature and the endian
            cool = filep.read(4)
            if cool == b'cool':
                # Big endian
                endian = '>'
            elif cool == b'looc':
                # Little endian
                endian = '<'
            else:
                print(
                    'Codewarrior "cool" signature not found!',
                    file=sys.stderr)
                return None, None, None

            # Get the offset to the strings
            filep.seek(16)
            index_offset = struct_unpack(endian + 'I', filep.read(4))[0]
            filep.seek(index_offset)
            string_offset = struct_unpack(endian + 'I', filep.read(4))[0]

            # Read in the version
            filep.seek(28)
            cw_version = bytearray(filep.read(4))

            # Load the string 'CodeWarrior Project'
            filep.seek(40)
            if filep.read(19) != b'CodeWarrior Project':
                print(
                    '"Codewarrior Project" signature not found!',
                    file=sys.stderr)
                return None, None, None

            # Read in the strings for the targets
            filep.seek(string_offset)
            targets = []
            linkers = []
            # Scan for known linkers
            while True:
                item = read_zero_terminated_string(filep)
                if not item:
                    break

                # Only strings with a colon are parsed
                parts = item.split(':')
                if len(parts) == 2:
                    # Target:panel
                    target = parts[0]
                    panel = parts[1]

                    # Add the target
                    if target not in targets:
                        targets.append(target)

                    # Add the linker if supported
                    if panel in _CW_SUPPORTED_LINKERS:
                        if panel not in linkers:
                            linkers.append(panel)

            return targets, linkers, cw_version

    except IOError as error:
        print(str(error), file=sys.stderr)

    return None, None, None

########################################


def build_codewarrior(full_pathname, verbose=False, fatal=False):
    """
    Build a Metrowerks Codewarrior file.

    Supports .mcp files for Windows, Mac, Wii and DSI.

    Args:
        full_pathname: Pathname to the Visual Studio .sln file
        verbose: True for verbose output
        fatal: If True, abort on the first failed build
    Returns:
        List of BuildError objects
    See Also:
        parse_mcp_file
    """

    # Too many return statements
    # Too many branches
    # Too many statements
    # pylint: disable=R0911,R0912,R0915

    # Test for older macOS or Windows
    if get_mac_host_type():
        if not is_codewarrior_mac_allowed():
            return BuildError(
                0, full_pathname,
                msg='Codewarrior is not compatible with this version of macOS')
    elif not get_windows_host_type():
        return BuildError(
            0, full_pathname,
            msg='Codewarrior is not compatible with this operating system')

    # Handle ../../
    full_pathname = os.path.abspath(full_pathname)

    # Parse the MCP file to get the build targets and detected linkers
    targets, linkers, _ = parse_mcp_file(full_pathname)
    if targets is None:
        return BuildError(0, full_pathname, msg='File corrupt')

    # Test which version of the CodeWarrior IDE that should be launched to
    # build a project with specific linkers.

    cw_path = None
    if get_windows_host_type():
        # Test for linkers that are not available on Windows
        if '68K Linker' in linkers:
            return BuildError(
                0, full_pathname,
                msg="Requires a 68k linker which Windows doesn't support.")
        if 'PPC Linker' in linkers:
            return BuildError(
                0, full_pathname,
                msg="Requires a PowerPC linker which Windows doesn't support.")

        # Determine which version of CodeWarrior to run.

        # Test for 3DS or DSI
        if 'MW ARM Linker Panel' in linkers:
            cw_path = os.getenv('CWFOLDER_NITRO', default=None)
            if cw_path is None:
                cw_path = os.getenv('CWFOLDER_TWL', default=None)

        # Test for Nintendo Wii
        elif 'PPC EABI Linker' in linkers:
            cw_path = os.getenv('CWFOLDER_RVL', default=None)

        # Test for Windows
        elif 'x86 Linker' in linkers:
            cw_path = os.getenv('CWFolder', default=None)

        if cw_path is None:
            return BuildError(
                0, full_pathname,
                msg="CodeWarrior with propler linker is not installed.")

        # Note: CmdIDE is preferred, however, Codewarrior 9.4 has a bug
        # that it will die horribly if the pathname to it
        # has a space, so ide is used instead.
        cw_path = os.path.join(cw_path, 'Bin', 'IDE.exe')
    else:

        # Handle mac version

        # Only CodeWarrior 9 has the Windows linker
        if 'x86 Linker' in linkers:
            cw_path = (
                '/Applications/Metrowerks CodeWarrior 9.0'
                '/Metrowerks CodeWarrior/CodeWarrior IDE')
            if not os.path.isfile(cw_path):
                # Try an alternate path
                cw_path = (
                    '/Applications/Metrowerks CodeWarrior 9.0'
                    '/Metrowerks CodeWarrior/CodeWarrior IDE 9.6')

        # Build with CodeWarrior 10
        elif any(i in ('68K Linker', 'PPC Linker') for i in linkers):
            cw_path = (
                '/Applications/Metrowerks CodeWarrior 10.0'
                '/Metrowerks CodeWarrior/CodeWarrior IDE')
            if not os.path.isfile(cw_path):
                # Alternate path
                cw_path = (
                    '/Applications/Metrowerks CodeWarrior 10.0'
                    '/Metrowerks CodeWarrior/CodeWarrior IDE 10')
        if cw_path is None:
            return BuildError(
                0, full_pathname,
                msg="CodeWarrior with proper linker is not installed.")

    # If there's an "Uber" target, just use that
    if 'Everything' in targets:
        targets = ['Everything']

    # Create the temp folder in case there's an error file generated
    mytempdir = os.path.join(os.path.dirname(full_pathname), 'temp')
    create_folder_if_needed(mytempdir)

    results = []
    for target in targets:

        # Use the proper dispatcher
        if get_windows_host_type():
            # Create the build command
            # /s New instance
            # /t Project name
            # /b Build
            # /c close the project after completion
            # /q Close Codewarrior on completion
            cmd = [cw_path, full_pathname, '/t', target, '/s', '/c', '/q', '/b']
        else:
            # Create the folder for the error log
            error_file = os.path.join(mytempdir, '{}-{}.err'.format(
                os.path.splitext(os.path.basename(full_pathname))[0], target))
            cmd = ['cmdide', '-proj', '-bcwef', error_file,
                   '-y', cw_path, '-z', target, full_pathname]

        if verbose:
            print(' '.join(cmd))
        try:
            error_code = run_command(
                cmd, working_dir=os.path.dirname(full_pathname),
                quiet=not verbose)[0]
            msg = None
            if error_code and error_code < len(CODEWARRIOR_ERRORS):
                msg = CODEWARRIOR_ERRORS[error_code]
        except OSError as error:
            error_code = getattr(error, 'winerror', error.errno)
            msg = str(error)
            print(msg, file=sys.stderr)

        results.append(
            BuildError(
                error_code,
                full_pathname,
                configuration=target,
                msg=msg))
        if error_code and fatal:
            break

    return results

########################################


def parse_xcodeproj_dir(full_pathname):
    """
    Extract configurations from an XCode project file.

    Given a .xcodeproj directory for XCode for macOS
    locate and extract all of the build targets
    available and return the list.

    Args:
        full_pathname: Pathname to the .xcodeproj folder
    Returns:
        list of configuration strings
    See Also:
        build_xcode
    """

    # Start with an empty list

    targetlist = []
    try:
        with open(os.path.join(full_pathname, 'project.pbxproj'), 'r') as filep:
            projectfile = filep.read().splitlines()

    except IOError as error:
        print(str(error), file=sys.stderr)
        return targetlist

    configurationfound = False
    for line in projectfile:
        # Look for this section. Immediately after it
        # has the targets
        if configurationfound is False:
            if 'buildConfigurations' in line:
                configurationfound = True
        else:
            # Once the end of the section is reached, end
            if ');' in line:
                break
            # Format 1DEB923608733DC60010E9CD /* Debug */,
            # The third entry is the data needed
            targetlist.append(line.rsplit()[2])

    # Exit with the results
    return targetlist

########################################


def build_xcode(full_pathname, verbose=False, fatal=False):
    """
    Build a macOS XCode file.

    Supports .xcodeproj files from Xcode 3 and later.

    Args:
        full_pathname: Pathname to the Visual Studio .sln file
        verbose: True for verbose output
        fatal: If True, abort on the first failed build
    Returns:
        List of BuildError objects
    See Also:
        parse_xcodeproj_dir
    """

    # pylint: disable=too-many-locals

    # Get the list of build targets
    targetlist = parse_xcodeproj_dir(full_pathname)

    file_name_lower = full_pathname.lower()

    suffixes = (
        ('xc3', 3),
        ('xc4', 4),
        ('xc5', 5),
        ('xc6', 6),
        ('xc7', 7),
        ('xc8', 8),
        ('xc9', 9),
        ('x10', 10)
    )

    for item in suffixes:
        if item[0] in file_name_lower:
            version = item[1]
            break
    else:
        version = None

    # Find XCode for the version needed
    xcode = where_is_xcode(version)

    # Is this version of XCode installed?
    if not xcode or not os.path.isfile(xcode[0]):
        msg = ('Can\'t build {}, the proper version '
               'of XCode is not installed').format(full_pathname)
        print(msg)
        return BuildError(0, full_pathname,
                          msg=msg)

    xcodebuild = xcode[0]
    # Build each and every target
    results = []
    for target in targetlist:
        # Create the build command
        cmd = [
            xcodebuild,
            '-project',
            os.path.basename(full_pathname),
            '-alltargets',
            '-parallelizeTargets',
            '-configuration',
            target]

        if verbose:
            print(' '.join(cmd))

        try:
            error_code = run_command(
                cmd, working_dir=os.path.dirname(full_pathname),
                quiet=not verbose)[0]
            msg = None
        except OSError as error:
            error_code = getattr(error, 'winerror', error.errno)
            msg = str(error)
            print(msg, file=sys.stderr)

        results.append(
            BuildError(
                error_code,
                full_pathname,
                configuration=target))
        if error_code and fatal:
            break

    return results

########################################


def parse_codeblocks_file(full_pathname):
    """
    Extract configurations from a Codeblocks project file.

    Given a .cbp file for Codeblocks
    locate and extract all of the build targets
    available and return the list.

    Args:
        full_pathname: Pathname to the .cdp file
    Returns:
        list of configuration strings
    See Also:
        build_codeblocks
    """

    # Too many nested blocks
    # pylint: disable=R0101

    # Start with an empty list
    targetlist = []

    # Parse the XML file
    try:
        tree = ET.parse(full_pathname)
    except IOError as error:
        print(str(error), file=sys.stderr)
        return targetlist

    # Traverse the tree and extract the targets
    root = tree.getroot()
    for child in root:
        if child.tag == 'Project':
            for item in child:
                if item.tag == 'Build':
                    for item2 in item:
                        if item2.tag == 'Target':
                            target = item2.attrib.get('title')
                            if target:
                                targetlist.append(target)
                elif item.tag == 'VirtualTargets':
                    for item2 in item:
                        if item2.tag == 'Add':
                            target = item2.attrib.get('alias')
                            if target:
                                targetlist.append(target)

    # Exit with the results
    return targetlist

########################################


def build_codeblocks(full_pathname, verbose=False, fatal=False):
    """
    Build a Codeblocks project.

    Support .cbp files for Codeblocks on all host platforms.

    Args:
        full_pathname: Pathname to the Codeblocks .cbp file
        verbose: True for verbose output
        fatal: If True, abort on the first failed build
    Returns:
        List of BuildError objects
    See Also:
       parse_codeblocks_file
    """

    # Commands available as of 13.12
    # --safe-mode
    # --no-check-associations
    # --no-dde
    # --no-splash-screen
    # --multiple-instance
    # --debug-log
    # --no-crash-handler
    # --verbose
    # --no-log
    # --log-to-file
    # --debug-log-to-file
    # --rebuild
    # --build
    # --clean
    # --target=
    # --no-batch-window-close
    # --batch-build-notify
    # --script=
    # --file=

    # Is Codeblocks installed?
    codeblocks_path = where_is_codeblocks()
    if codeblocks_path is None:
        return BuildError(
            0, full_pathname,
            msg='Requires Codeblocks to be installed to build!')

    if get_windows_host_type():
        if full_pathname.endswith('osx.cbp'):
            return BuildError(0, full_pathname,
                              msg="Can only be built on macOS")
        codeblocksflags = ['--no-check-associations', '--no-dde']
    else:
        if not full_pathname.endswith('osx.cbp'):
            return BuildError(0, full_pathname, msg="Can not be built on macOS")
        codeblocksflags = ['--no-ipc']

    # Handle ../../
    full_pathname = os.path.abspath(full_pathname)

    # Parse the CBP file to get the build targets and detected linkers
    targets = parse_codeblocks_file(full_pathname)
    if targets is None:
        return BuildError(0, full_pathname, msg='File corrupt')

    if 'Everything' in targets:
        targets = ['Everything']

    results = []
    for target in targets:
        # Create the build command
        cmd = [codeblocks_path]
        cmd.extend(codeblocksflags)
        cmd.extend(['--no-splash-screen', '--build',
                    full_pathname, '--target=' + target])

        if verbose:
            print(' '.join(cmd))
        try:
            error_code = run_command(
                cmd, working_dir=os.path.dirname(full_pathname),
                quiet=not verbose)[0]
            msg = None
        except OSError as error:
            error_code = getattr(error, 'winerror', error.errno)
            msg = str(error)
            print(msg, file=sys.stderr)
        results.append(
            BuildError(
                error_code,
                full_pathname,
                configuration=target))
        if error_code and fatal:
            break
    return results

########################################


def add_build_rules(projects, file_name, args):
    """
    Add a build_rules.py to the build list.

    Given a build_rules.py to parse, check it for a BUILD_LIST
    and use that for scanning for functions to call. If BUILD_LIST
    doesn't exist, use @ref buildme.BUILD_LIST instead.

    All valid entries will be appended to the projects list.

    Args:
        projects: List of projects to build.
        file_name: Pathname to the build_rules.py file.
        args: Args for determining verbosity for output.
    See Also:
       add_project, get_projects
    """

    file_name = os.path.abspath(file_name)
    build_rules = import_py_script(file_name)
    if build_rules:
        if args.verbose:
            print('Using configuration file {}'.format(file_name))

        # Test for functions and append all that are found
        rules = getattr(build_rules, 'rules', None)
        for item in BUILD_LIST:
            # Only add if it's a function
            projects.append(
                BuildObject(
                    file_name,
                    'python:' + item[1],
                    item[0],
                    function_ref=rules))


########################################


def add_project(projects, file_name, args):
    """
    Detect the project type and add it to the list.

    Args:
        projects: List of projects to build.
        file_name: Pathname to the build_rules.py file.
        args: Args for determining verbosity for output.
    Returns:
        True if the file was buildable, False if not.
    """

    # Too many branches
    # pylint: disable=R0912

    # Only process project files
    base_name = os.path.basename(file_name)
    base_name_lower = base_name.lower()
    projecttype = None
    priority = 50
    if base_name == 'prebuild.py':
        projecttype = 'python'
        priority = 1
    elif base_name == BUILD_RULES_PY:
        if not args.rules_file:
            return add_build_rules(projects, file_name, args)
    elif base_name_lower.endswith('.slicerscript'):
        projecttype = 'slicer'
        priority = 20
    elif base_name_lower.endswith('.rezscript'):
        projecttype = 'makerez'
        priority = 25
    elif base_name == 'custombuild.py':
        projecttype = 'python'
        priority = 40
    elif base_name_lower.endswith('.sln'):
        projecttype = 'visualstudio'
        priority = 45
    elif base_name_lower.endswith('.mcp'):
        projecttype = 'codewarrior'
    elif base_name_lower.endswith('.wmk'):
        projecttype = 'watcommakefile'
    elif base_name_lower == 'makefile' or base_name_lower.endswith('.mak'):
        projecttype = 'makefile'
    elif base_name_lower.endswith('.xcodeproj'):
        projecttype = 'xcode'
    elif base_name_lower.endswith('.cbp'):
        projecttype = 'codeblocks'
    elif base_name_lower == 'doxyfile':
        projecttype = 'doxygen'
        priority = 90
    elif base_name == 'postbuild.py':
        projecttype = 'python'
        priority = 99

    if projecttype:
        projects.append(BuildObject(file_name, projecttype, priority))
        return True
    return False


########################################

def get_projects(projects, working_directory, args):
    """
    Scan a folder for files that need to be 'built'.

    Args:
        projects: List of projects to build.
        working_directory: Directory to scan.
        args: Args for determining verbosity for output.
    """

    # Get the list of files in this directory
    try:
        for base_name in os.listdir(working_directory):
            file_name = os.path.join(working_directory, base_name)
            add_project(projects, file_name, args)
    except OSError as error:
        print(error)

########################################


def process(working_directory, args, results):
    """
    Build a specific directory.

    Args:
        working_directory: Directory to pass to the ``clean_rules`` function
        args: Args for determining verbosity for output
        results: List to append BuildError records
    Returns:
        Zero on no error, non zero integer on error
    """

    # Too many branches
    # Too many statements
    # pylint: disable=R0912,R0915
    if args.verbose:
        print('Building "{}".'.format(working_directory))

    # List of files to build
    projects = []

    # Handle the case of specific files to build

    if args.rules_file:
        add_build_rules(projects, args.rules_file, args)

    if args.args:
        for item in args.args:
            projectname = os.path.join(working_directory, item)
            if add_project(projects, projectname, args) is False:
                print(('Error: {} is not a '
                       'known project file.').format(projectname))
                return 10
    else:
        get_projects(projects, working_directory, args)

    # Sort the list by priority (The third parameter is priority from 1-99
    error = 0
    projects = sorted(projects, key=attrgetter('priority'))
    for project in projects:
        fullpathname = project.file_name
        projecttype = project.build_type
        berror = None

        # Is it a python script?
        if projecttype.startswith('python'):
            if not project.has_python_function():
                if args.verbose:
                    print('Invoking ' + fullpathname)
                error = run_py_script(
                    fullpathname, 'main', os.path.dirname(fullpathname))
            else:
                func_name = projecttype.split(':')[1]
                if args.verbose:
                    print(
                        'Calling {}(command="{}") in {}'.format(
                            project.function_ref.__name__,
                            func_name,
                            fullpathname))
                error = project.function_ref(
                    func_name, working_directory=working_directory)
            berror = BuildError(error, fullpathname)

        # Is it a slicer script?
        elif projecttype == 'slicer':
            berror = build_slicer_script(fullpathname, verbose=args.verbose)

        # Is it a makerez script?
        elif projecttype == 'makerez':
            berror = build_rez_script(fullpathname, verbose=args.verbose)

        # Is this a doxygen file?
        elif projecttype == 'doxygen':
            if args.documentation:
                berror = build_doxygen(fullpathname, verbose=args.verbose)

        # Is this a Watcom Makefile?
        elif projecttype == 'watcommakefile':
            berror = build_watcom_makefile(fullpathname, verbose=args.verbose,
                                           fatal=args.fatal)

        # Is this a Linux Makefile?
        elif projecttype == 'makefile':
            berror = build_makefile(fullpathname, verbose=args.verbose,
                                    fatal=args.fatal)

        # Visual studio solution files?
        elif projecttype == 'visualstudio':
            if get_windows_host_type():
                berror = build_visual_studio(fullpathname, verbose=args.verbose,
                                             fatal=args.fatal)

        # Metrowerks Codewarrior files?
        elif projecttype == 'codewarrior':
            berror = build_codewarrior(
                fullpathname, verbose=args.verbose, fatal=args.fatal)

        # XCode project file?
        elif projecttype == 'xcode':
            if get_mac_host_type():
                berror = build_xcode(
                    fullpathname,
                    verbose=args.verbose,
                    fatal=args.fatal)

        # Codeblocks project file?
        elif projecttype == 'codeblocks':
            berror = build_codeblocks(
                fullpathname,
                verbose=args.verbose,
                fatal=args.fatal)

        error = 0
        if berror is not None:
            if isinstance(berror, BuildError):
                results.append(berror)
                error = berror.error
            else:
                results.extend(berror)
                for i in berror:
                    if i.error:
                        error = i.error
                        break

        # Abort on error?
        if error and args.fatal:
            break

    # If recursive, process all the sub folders
    if args.recursive and not error:
        # Iterate over the directory
        for item in os.listdir(working_directory):

            # Ignore xcode project directories
            if _XCODEPROJ_MATCH.match(item):
                continue

            path_name = os.path.join(working_directory, item)
            if os.path.isdir(path_name):
                error = process(path_name, args, results)
                if error:
                    break

    return error


########################################


def main(working_directory=None, args=None):
    """
    Command line shell for ``buildme``.

    Entry point for the program ``buildme``, this function
    will either get the parameters from ``sys.argv`` or the paramater ``args``.

    - ``--version``, show version.
    - ``-r``, Perform a recursive rebuild.
    - ``-v``, Verbose output.
    - ``--generate-rules``, Create build_rules.py and exit.
    - ``--rules-file``, Override the configruration file.
    - ``-f``, Stop building on the first build failure.
    - ``-d``, List of directories to rebuild.
    - ``-docs``, Compile Doxyfile files.
    - Additional terms are considered specific files to build.

    Args:
        working_directory: Directory to operate on, or ``None``.
        args: Command line to use instead of ``sys.argv``.
    Returns:
        Zero on no error, non-zero on error
    """

    # Too many branches
    # pylint: disable=R0912
    # Make sure working_directory is properly set
    if working_directory is None:
        working_directory = os.getcwd()

    # Parse the command line
    parser = argparse.ArgumentParser(
        description='Build project files. Copyright by Rebecca Ann Heineman. '
        'Builds *.sln, *.mcp, *.cbp, *.wmk, *.rezscript, *.slicerscript, '
        'doxyfile, makefile and *.xcodeproj files')

    parser.add_argument('--version', action='version',
                        version='%(prog)s ' + VERSION)
    parser.add_argument('-r', '-all', dest='recursive', action='store_true',
                        default=False, help='Perform a recursive build')
    parser.add_argument('-v', '-verbose', dest='verbose', action='store_true',
                        default=False, help='Verbose output.')
    parser.add_argument('--generate-rules', dest='generate_build_rules',
                        action='store_true', default=False,
                        help='Generate a sample configuration file and exit.')
    parser.add_argument(
        '--rules-file',
        dest='rules_file',
        metavar='<file>',
        default=None,
        help='Specify a configuration file.')

    parser.add_argument('-f', dest='fatal', action='store_true',
                        default=False, help='Quit immediately on any error.')
    parser.add_argument('-d', dest='directories', action='append',
                        metavar='<directory>',
                        help='List of directories to build in.')
    parser.add_argument('-docs', dest='documentation', action='store_true',
                        default=False, help='Compile Doxyfile files.')
    parser.add_argument('args', nargs=argparse.REMAINDER,
                        help='project filenames')

    # Parse everything
    args = parser.parse_args(args=args)

    # Output default configuration
    if args.generate_build_rules:
        # pylint: disable=import-outside-toplevel
        from .config import save_default
        if args.verbose:
            print(
                'Saving {}'.format(
                    os.path.join(
                        working_directory,
                        BUILD_RULES_PY)))
        save_default(working_directory)
        return 0

    # Make a list of directories to process
    if not args.directories:
        args.directories = [working_directory]

    # Process the directories
    results = []
    for item in args.directories:
        if process(os.path.abspath(item), args, results):
            break

    # List all the projects that failed
    for item in results:
        if item.error:
            print('Errors detected in the build.', file=sys.stderr)
            error = item.error
            break
    else:
        if args.verbose:
            print('Build successful!')
        error = 0

    # Dump the error log
    if args.verbose or error:
        for item in results:
            if args.verbose or item.error:
                print(item)
    return error


# If called as a function and not a class, call my main
if __name__ == "__main__":
    sys.exit(main())
